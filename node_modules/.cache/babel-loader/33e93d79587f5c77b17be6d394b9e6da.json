{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\n\nfunction isLight(object) {\n  return object.isLight;\n}\n\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\n\nconst accumulativeContext = /*#__PURE__*/React.createContext(null);\nconst AccumulativeShadows = /*#__PURE__*/React.forwardRef((_ref, forwardRef) => {\n  let {\n    children,\n    temporal,\n    frames = 40,\n    limit = Infinity,\n    blend = 20,\n    scale = 10,\n    opacity = 1,\n    alphaTest = 0.65,\n    color = 'black',\n    resolution = 1024,\n    ...props\n  } = _ref;\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []); //const [lights, setLights] = React.useState<AccumulativeLightContext[]>([])\n\n  const material = React.useMemo(() => {\n    const mat = Object.assign(new THREE.MeshBasicMaterial({\n      opacity: 0,\n      transparent: true,\n      dithering: true,\n      depthWrite: false,\n      map: plm.progressiveLightMap2.texture\n    }), {\n      uniforms: {\n        ucolor: {\n          value: new THREE.Color(color)\n        },\n        alphaTest: {\n          value: 0\n        }\n      }\n    });\n\n    mat.onBeforeCompile = shader => {\n      mat.uniforms = shader.uniforms = { ...shader.uniforms,\n        ...mat.uniforms\n      };\n      shader.fragmentShader = shader.fragmentShader.replace(`void main() {`, `uniform vec3 ucolor;\n           uniform float alphaTest;\n           void main() {`);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', `#include <dithering_fragment>\n           gl_FragColor = vec4(ucolor * gl_FragColor.r * 2.0, max(0.0, (1.0 - gl_FragColor.r / alphaTest)) * opacity);`);\n    };\n\n    return mat;\n  }, [color]);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      material.opacity = 0;\n      material.uniforms.alphaTest.value = 0;\n      api.count = 0;\n    },\n    update: function () {\n      let frames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      // Adapt the opacity-blend ratio to the number of frames\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.uniforms.alphaTest.value = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.uniforms.alphaTest.value = Math.min(alphaTest, material.uniforms.alphaTest.value + alphaTest / api.blend);\n      } // Switch accumulative lights on\n\n\n      gLights.current.visible = true; // Collect scene lights and meshes\n\n      plm.prepare(); // Update the lightmap and the accumulative lights\n\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      } // Switch lights off\n\n\n      gLights.current.visible = false; // Restore lights and meshes\n\n      plm.finish();\n    }\n  }), [plm, material, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset(); // Update lightmap\n\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  }); // Expose api, allow children to set itself as the main light source\n\n  React.useImperativeHandle(forwardRef, () => api, []);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    material: material,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null)));\n});\nconst RandomizedLight = /*#__PURE__*/React.forwardRef((_ref2, forwardRef) => {\n  let {\n    castShadow = true,\n    bias = 0,\n    mapSize = 512,\n    size = 5,\n    near = 0.5,\n    far = 500,\n    frames = 1,\n    position = [0, 0, 0],\n    radius = 1,\n    amount = 8,\n    intensity = 1,\n    ambient = 0.5,\n    ...props\n  } = _ref2;\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    const group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return () => void parent.lights.delete(group.uuid);\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n});\n\nclass UVMaterial extends THREE.ShaderMaterial {\n  constructor() {\n    super({\n      vertexShader: 'void main() { gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }',\n      fragmentShader: 'void main() { discard; }'\n    });\n  }\n\n} // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\n\n\nclass ProgressiveLightMap {\n  constructor(renderer, scene) {\n    let res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1024;\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.scene.background = null;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.uvMat = new UVMaterial();\n    this.targetMat = new THREE.MeshPhongMaterial({\n      shininess: 0\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = shader.fragmentShader.replace('#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n      }`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n\n  clear() {\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isGeometry(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.uvMat);\n  }\n\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n\n  configure(object) {\n    this.object = object;\n  }\n\n  update(camera) {\n    let blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    if (!this.object) return; // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat; // Ping-pong two surface buffers for reading/writing\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n  }\n\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };","map":{"version":3,"names":["_extends","THREE","React","useThree","useFrame","isLight","object","isGeometry","geometry","accumulativeContext","createContext","AccumulativeShadows","forwardRef","children","temporal","frames","limit","Infinity","blend","scale","opacity","alphaTest","color","resolution","props","gl","state","scene","camera","gPlane","useRef","gLights","plm","useState","ProgressiveLightMap","useLayoutEffect","configure","current","material","useMemo","mat","Object","assign","MeshBasicMaterial","transparent","dithering","depthWrite","map","progressiveLightMap2","texture","uniforms","ucolor","value","Color","onBeforeCompile","shader","fragmentShader","replace","api","lights","Map","Math","max","count","reset","clear","update","min","visible","prepare","i","forEach","light","finish","useImperativeHandle","createElement","traverse","ref","Provider","receiveShadow","rotation","PI","RandomizedLight","castShadow","bias","mapSize","size","near","far","position","radius","amount","intensity","ambient","length","Vector3","parent","useContext","useCallback","l","random","set","MathUtils","randFloatSpread","lambda","acos","phi","cos","abs","sin","group","uuid","delete","Array","from","_","index","key","attach","args","UVMaterial","ShaderMaterial","constructor","vertexShader","renderer","res","background","buffer1Active","meshes","format","test","navigator","userAgent","HalfFloatType","FloatType","progressiveLightMap1","WebGLRenderTarget","type","uvMat","targetMat","MeshPhongMaterial","shininess","previousShadowMap","averagingWindow","slice","bodyStart","indexOf","setRenderTarget","push","mesh","blendWindow","activeMap","inactiveMap","render"],"sources":["/Users/jcsoutherland/Documents/GitHub/portfolio-two/node_modules/@react-three/drei/core/AccumulativeShadows.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\n\nfunction isLight(object) {\n  return object.isLight;\n}\n\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\n\nconst accumulativeContext = /*#__PURE__*/React.createContext(null);\nconst AccumulativeShadows = /*#__PURE__*/React.forwardRef(({\n  children,\n  temporal,\n  frames = 40,\n  limit = Infinity,\n  blend = 20,\n  scale = 10,\n  opacity = 1,\n  alphaTest = 0.65,\n  color = 'black',\n  resolution = 1024,\n  ...props\n}, forwardRef) => {\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []); //const [lights, setLights] = React.useState<AccumulativeLightContext[]>([])\n\n  const material = React.useMemo(() => {\n    const mat = Object.assign(new THREE.MeshBasicMaterial({\n      opacity: 0,\n      transparent: true,\n      dithering: true,\n      depthWrite: false,\n      map: plm.progressiveLightMap2.texture\n    }), {\n      uniforms: {\n        ucolor: {\n          value: new THREE.Color(color)\n        },\n        alphaTest: {\n          value: 0\n        }\n      }\n    });\n\n    mat.onBeforeCompile = shader => {\n      mat.uniforms = shader.uniforms = { ...shader.uniforms,\n        ...mat.uniforms\n      };\n      shader.fragmentShader = shader.fragmentShader.replace(`void main() {`, `uniform vec3 ucolor;\n           uniform float alphaTest;\n           void main() {`);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', `#include <dithering_fragment>\n           gl_FragColor = vec4(ucolor * gl_FragColor.r * 2.0, max(0.0, (1.0 - gl_FragColor.r / alphaTest)) * opacity);`);\n    };\n\n    return mat;\n  }, [color]);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      material.opacity = 0;\n      material.uniforms.alphaTest.value = 0;\n      api.count = 0;\n    },\n    update: (frames = 1) => {\n      // Adapt the opacity-blend ratio to the number of frames\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.uniforms.alphaTest.value = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.uniforms.alphaTest.value = Math.min(alphaTest, material.uniforms.alphaTest.value + alphaTest / api.blend);\n      } // Switch accumulative lights on\n\n\n      gLights.current.visible = true; // Collect scene lights and meshes\n\n      plm.prepare(); // Update the lightmap and the accumulative lights\n\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      } // Switch lights off\n\n\n      gLights.current.visible = false; // Restore lights and meshes\n\n      plm.finish();\n    }\n  }), [plm, material, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset(); // Update lightmap\n\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  }); // Expose api, allow children to set itself as the main light source\n\n  React.useImperativeHandle(forwardRef, () => api, []);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    material: material,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null)));\n});\nconst RandomizedLight = /*#__PURE__*/React.forwardRef(({\n  castShadow = true,\n  bias = 0,\n  mapSize = 512,\n  size = 5,\n  near = 0.5,\n  far = 500,\n  frames = 1,\n  position = [0, 0, 0],\n  radius = 1,\n  amount = 8,\n  intensity = 1,\n  ambient = 0.5,\n  ...props\n}, forwardRef) => {\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    const group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return () => void parent.lights.delete(group.uuid);\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n});\n\nclass UVMaterial extends THREE.ShaderMaterial {\n  constructor() {\n    super({\n      vertexShader: 'void main() { gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }',\n      fragmentShader: 'void main() { discard; }'\n    });\n  }\n\n} // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\n\n\nclass ProgressiveLightMap {\n  constructor(renderer, scene, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.scene.background = null;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.uvMat = new UVMaterial();\n    this.targetMat = new THREE.MeshPhongMaterial({\n      shininess: 0\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = shader.fragmentShader.replace('#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n      }`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n\n  clear() {\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isGeometry(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.uvMat);\n  }\n\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n\n  configure(object) {\n    this.object = object;\n  }\n\n  update(camera, blendWindow = 100) {\n    if (!this.object) return; // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat; // Ping-pong two surface buffers for reading/writing\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n  }\n\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}